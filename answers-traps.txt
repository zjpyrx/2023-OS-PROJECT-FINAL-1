（具体内容和图片写在报告里）
1. 编译`user/call.c`文件，生成`user/call.asm`文件。其中与call中的main，printf，f，g函数如下图所示：

   ![image-20230727223913735](assets/image-20230727223913735.png)

   ![image-20230727223935033](assets/image-20230727223935033.png)

   ![image-20230727224014974](assets/image-20230727224014974.png)

2. **哪些寄存器保留了函数的参数？例如，在main调用printf时，哪个寄存器保留了13？**

   一般来说a0~a7用来存放函数的参数。阅读call.asm可得a2保留了13。

3. **main的汇编语言中，对函数f的调用在哪里？g的调用在哪里？（提示：编译器可能会内联函数。）**

   可以看到上图main没有任何跳转到f、g的语句。此处是编译器将f内联在了main中，直接计算得到了f(8)的值，同样也将g的语句内联在了f中，提高了运行效率。

4. **printf的地址在哪里？**

   跳转到printf的指令：jalr  1536(ra) 而在上一句的auipc  ra,0x0中，ra被设置为当前pc的高位，也就是0x30+1536=0x630（备注里也写了，630 <printf>）

5. **在main中jalr到printf之后，寄存器ra中的值是什么**

   0x34 + 4 = 0x38。0x30行，设置为当前pc高位后，auipc在ra存储返回地址，跳转指令时pc为0x34，将pc+4后赋值给ra，即为0x38。

6. **运行以下代码：`unsigned int i = 0x00646c72;  printf("H%x Wo%s", 57616, &i);`结果是什么？输出取决于RISC-V是小端对齐。如果RISC-V是大端对齐的，为了得到同样的输出，应该把i设置为什么？是否需要将51676更改为不同的值？**

   新建`user/lab4-test-code.c`并放入代码，加入makefile，输出：

   ![image-20230728162428716](assets/image-20230728162428716.png)

   %x为输出为16进制，57616的16进制为e110。%s为以&i（0x00646c72）为首地址输出字符串，因为RISC-V为小端对齐，所以输出是：0x72，0x6c，0x64，0x00对应的ascii码表中的值（遇到0结尾）。查表得分别对应r，l，d。

   如果是大端对齐，可以设置为0x726c6400，57616不用更改。

7. **在以下代码:`printf("x=%d y=%d", 3);`中，“y=”后面会打印出什么？（答案不是一个特定的值）。为什么会这样？**

   将`user/lab4-test-code.c`中内容改成上述代码，输出：

   ![image-20230728162515268](assets/image-20230728162515268.png)

   打印出x=3,y=不确定值。因为打印时printf读取了a1，a2的内容，a1传入了3，a2没有传入特定值，所以打出来是不确定的特殊值。